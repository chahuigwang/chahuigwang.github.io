---
title: 스프링 MVC - 기본 기능
date: 2025-10-27 20:51:00 +0900
categories: [Spring, Spring MVC]
tags: [spring]
---

# Spring MVC - 기본 기능
---
## 요청 매핑
- `@RestController`
  - `@Controller` 는 반환 값이 `String` 이면 뷰 이름으로 인식된다. 그래서 **뷰를 찾고 뷰가 랜더링** 된다.
  - `@RestController` 는 반환 값으로 뷰를 찾는 것이 아니라, **HTTP 메시지 바디에 바로 입력**한다.
- `@RequestMapping`
  - 기본 요청
  - HTTP 메서드 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE

#### HTTP 메서드 매핑
`@RequestMapping` 에 `method` 속성으로 HTTP 메서드를 지정할 수 있다 ex) `@RequestMapping(value = "경로", method = RequestMethod.(HTTP 메서드))`  

**HTTP 메서드 매핑 축약**
- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@DeleteMapping`
- `@PatchMapping`

**PathVariable(경로 변수) 사용**
```java
@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data) {
    log.info("mappingPath userId={}", data);
    return "ok";
}
```

- 변수명이 같으면 생략 가능
- `@PathVariable("userId") String userId` ➡️ `@PathVariable String userId`

### 요청 매핑 - API 예시
**회원 관리 API**
- 회원 목록 조회: GET    `/users`
- 회원 등록:     POST   `/users`
- 회원 조회:     GET    `/users/{userId}`
- 회원 수정:     PATCH  `/users/{userId}`
- 회원 삭제:     DELETE `/users/{userId}`

```java
@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {
    /**
    * GET /mapping/users
    */
    @GetMapping
    public String users() {
        return "get users";
    }
    /**
    * POST /mapping/users
    */
    @PostMapping
    public String addUser() {
        return "post user";
    }
    /**
    * GET /mapping/users/{userId}
    */
    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId=" + userId;
    }
    /**
    * PATCH /mapping/users/{userId}
    */ 
    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId=" + userId;
    }
    /**
    * DELETE /mapping/users/{userId}
    */
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId=" + userId;
    }
}
```

- `@RequestMapping("/mapping/users")`
  - 클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.


## HTTP 요청 파라미터 - 쿼리 파라미터, HTML Form
**클라이언트에서 서버로 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용한다.**
- **GET - 쿼리 파라미터**
  - /url?username=hello&age=20
  - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
  - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식
- **POST - HTML Form**
  - content-type: application/x-www-form-urlencoded
  - 메시지 바디에 쿼리 파리미터 형식으로 전달 username=hello&age=20
  - 예) 회원 가입, 상품 주문, HTML Form 사용
- **HTTP message body**에 데이터를 직접 담아서 요청
  - HTTP API에서 주로 사용, JSON, XML, TEXT
  - 데이터 형식은 주로 JSON 사용
  - POST, PUT, PATCH

### @RequestParam
- HTTP 파라미터 이름이 변수 이름과 같으면 `@RequestParam(name = "이름")` 생략 가능
- String, int 등의 단순 타입이면 `@RequestParam` 도 생략 가능
- `required`
  - 파라미터 필수 여부
- `defaultValue`
  - 기본 값 설정

**파라미터를 Map으로 조회하기**
```java
public String requestParamMap(@RequestParam Map<String, Object> paramMap) {
    ...
}
```
- 파라미터를 Map, MultiValueMap으로 조회할 수 있다.
- 파라미터의 값이 1개가 확실하다면 `Map` 을 사용해도 되지만, 그렇지 않다면 `MultiValueMap` 을 사용하자.

### @ModelAttribute
```java
/**
설명
* @ModelAttribute 사용
* 참고: model.addAttribute(helloData) 코드도 함께 자동 적용됨, 뒤에 model을 설명할 때 자세히
*/
@ResponseBody
@RequestMapping("/model-attribute-v1")
public String modelAttribute(@ModelAttribute HelloData helloData) {
    log.info("username={}, age={}", helloData.getUsername(), helloData.getAge());
    return "ok";
}
```
스프링MVC는 `@ModelAttribute` 가 있으면 다음을 실행한다.
- `HelloData` 객체를 생성한다.
- 요청 파라미터의 이름으로 `HelloData` 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력(바인딩) 한다.
- 예) 파라미터 이름이 `username` 이면 `setUsername()` 메서드를 찾아서 호출하면서 값을 입력한다.  

`@ModelAttribute` 는 생략할 수 있다.  

스프링은 해당 생략시 다음과 같은 규칙을 적용한다.
- `String` , `int` , `Integer` 같은 단순 타입 = `@RequestParam`
- 나머지 = `@ModelAttribute` (argument resolver 로 지정해둔 타입 외)

## HTTP 요청 메시지 - 단순 텍스트
- **HTTP message body**에 데이터를 직접 담아서 요청
  - HTTP API에서 주로 사용, JSON, XML, TEXT
  - 데이터 형식은 주로 JSON 사용
  - POST, PUT, PATCH 

요청 파라미터와 다르게, HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우는 `@RequestParam` , `@ModelAttribute` 를 사용할 수 없다.

### **@RequestBody**
`@RequestBody` 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다.

#### HTTP 요청 메시지 - JSON
**@RequestBody 객체 파라미터**
```java
/**
* @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
* HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (content-type:
application/json)
*
*/
@ResponseBody
@PostMapping("/request-body-json-v3")
public String requestBodyJson(@RequestBody HelloData data) {
    log.info("username={}, age={}", data.getUsername(), data.getAge());
    return "ok";
}
``` 
- `@RequestBody HelloData data`
- `@RequestBody` 에 직접 만든 객체를 지정할 수 있다.

### HTTP 응답 - 정적 리소스, 뷰 템플릿
스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다.
- 정적 리소스
  - 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는, **정적 리소스**를 사용한다.
- 뷰 템플릿 사용
  - 예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
- HTTP 메시지 사용
  - HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.

**정적 리소스** 

스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다.
`/static` , `/public` , `/resources` ,`/META-INF/resources` 

`src/main/resources` 는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다.
따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.

**뷰 템플릿**  

스프링 부트는 기본 뷰 템플릿 경로를 제공한다.
- **뷰 템플릿 경로**
  - `src/main/resources/templates`

### HTTP 응답 - HTTP API, 메시지 바디에 직접 입력
- `ResponseEntity` 
  - `ResponseEntity` 는 `HttpEntity` 를 상속 받았는데, HttpEntity는 HTTP 메시지의 헤더, 바디 정보를 가지고 있다. `ResponseEntity` 는 여기에 더해서 HTTP 응답 코드를 설정할 수 있다.
- `@ResponseBody`
  - `@ResponseBody` 를 사용하면 view를 사용하지 않고, HTTP 메시지 컨버터를 통해서 HTTP 메시지를 직접 입력할 수 있다. `ResponseEntity` 도 동일한 방식으로 동작한다.
  - `ResponseEntity` 는 HTTP 응답 코드를 설정할 수 있는데, `@ResponseBody` 를 사용하면 이런 것을 설정하기 까다롭다.
- `@RestController`
  - `@Controller` 대신에 `@RestController` 애노테이션을 사용하면, 해당 컨트롤러에 모두 `@ResponseBody` 가 적용되는 효과가 있다.